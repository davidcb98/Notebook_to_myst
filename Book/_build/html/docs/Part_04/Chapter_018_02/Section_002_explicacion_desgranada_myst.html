

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>18.2. Explicación desgranada &#8212; Curso de Introducción a la Computación Cuántica</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/sphinx-book-theme.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.1e8bd061cd6da7fc9cf755528e8ffc24.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/myfile.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script kind="utterances">

    var commentsRunWhenDOMLoaded = cb => {
    if (document.readyState != 'loading') {
        cb()
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', cb)
    } else {
        document.attachEvent('onreadystatechange', function() {
        if (document.readyState == 'complete') cb()
        })
    }
}

var addUtterances = () => {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://utteranc.es/client.js";
    script.async = "async";

    script.setAttribute("repo", "davidcb98/CICC_UMA");
    script.setAttribute("issue-term", "pathname");
    script.setAttribute("theme", "github-light");
    script.setAttribute("label", "💬 comment");
    script.setAttribute("crossorigin", "anonymous");

    sections = document.querySelectorAll("div.section");
    if (sections !== null) {
        section = sections[sections.length-1];
        section.appendChild(script);
    }
}
commentsRunWhenDOMLoaded(addUtterances);
</script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'docs/Part_04/Chapter_018_02/Section_002_explicacion_desgranada_myst';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="18.3. Implementación aproximada de la QFT" href="Section_003_implementacion_aproximada_de_la_qft_myst.html" />
    <link rel="prev" title="18.1. La idea" href="Section_001_la_idea__myst.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <header class="bd-header navbar navbar-expand-lg bd-navbar">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/Logo_UMA.png" class="logo__image only-light" alt="Curso de Introducción a la Computación Cuántica - Home"/>
    <script>document.write(`<img src="../../../_static/Logo_UMA.png" class="logo__image only-dark" alt="Curso de Introducción a la Computación Cuántica - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../Part_01/Chapter_001_01_introduccion_myst.html">1. Introducción</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Conceptos básicos</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_02/Chapter_002_01_formalismo_matematico__myst.html">2. Formalismo matemático</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_002_02/Section_001_numeros_complejos_myst.html">2.1. Números complejos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_002_02/Section_002_vectores_myst.html">2.2. Vectores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_002_02/Section_003_operadores_myst.html">2.3. Operadores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_002_02/Section_004_tensores_myst.html">2.4. Tensores</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_002_02/Section_005_probabilidades_myst.html">2.5. Probabilidades</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_02/Chapter_003_01_fundamentos_de_mecanica_cuantica__myst.html">3. Fundamentos de Mecánica Cuántica</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_003_02/Section_001_axiomas_myst.html">3.1. Axiomas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_003_02/Section_002_bases_ortogonales_myst.html">3.2. Bases ortogonales</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_003_02/Section_003_medidas_estadisticas_myst.html">3.3. Medidas Estadísticas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_003_02/Section_004_evolucion_temporal_myst.html">3.4. Evolución temporal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_02/Chapter_003_02/Section_005_estados_mezcla_y_matriz_densidad_myst.html">3.5. Estados Mezcla y Matriz Densidad</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Fundamentos de Computación Cuántica</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_004_01_qubits_myst.html">4. Qubits</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_004_02/Section_001_definicion_y_bases_myst.html">4.1. Definición y bases</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_004_02/Section_002_el_estado_de_un_qubit_y_la_esfera_de_bloch_myst.html">4.2. El estado de un qúbit y la esfera de Bloch</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_005_01_puertas_simples_myst.html">5. Puertas simples</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_005_02/Section_001_rotaciones_en_la_esfera_de_bloch_myst.html">5.1. Rotaciones en la esfera de Bloch</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_005_02/Section_002_puertas_simples_myst.html">5.2. Puertas simples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_005_02/Section_003_circuitos_cuanticos_1_qubit_myst.html">5.3. Circuitos Cuánticos (1 qubit)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_006_01_medidas%2C_parte_i_medida_de_1_qubit_myst.html">6. Medidas, Parte I: Medida de 1 qúbit</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_006_02/Section_001_en_la_base_computacional_myst.html">6.1. En la base computacional</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_006_02/Section_002_la_moneda_cuantica_myst.html">6.2. La moneda cuántica</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_006_02/Section_003_medidas_en_una_base_general_myst.html">6.3. Medidas en una base general</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_006_02/Section_004_valores_esperados_myst.html">6.4. Valores esperados.</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_007_01_multi-qubit_definiciones_y_puertas_myst.html">7. Multi-qubit: definiciones y puertas.</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_007_02/Section_001_algunas_definiciones_myst.html">7.1. Algunas definiciones</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_007_02/Section_002_entrelazamiento_myst.html">7.2. Entrelazamiento</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_007_02/Section_003_circuitos_multiqubit_myst.html">7.3. Circuitos Multiqubit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_007_02/Section_004_puertas_multi-qubit_no_controladas_myst.html">7.4. Puertas (multi-qubit) no controladas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_007_02/Section_005_puertas_controladas_myst.html">7.5. Puertas controladas</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_007_02/Section_006_puertas_multicontroladas_myst.html">7.6. Puertas multicontroladas</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_008_01_medidas%2C_parte_ii_medida_de_estados_multi-qubit_myst.html">8. Medidas, Parte II: Medida de estados multi-Qubit</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_008_02/Section_001_medidas_en_la_base_computacional_myst.html">8.1. Medidas en la base computacional</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_008_02/Section_002_medidas_en_bases_generales_myst.html">8.2. Medidas en bases generales</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_008_02/Section_003_valores_esperados_myst.html">8.3. Valores esperados</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_008_02/Section_004_medida_de_hadamard_myst.html">8.4. Medida de Hadamard</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_009_01_entrelazamiento_en_accion_myst.html">9. Entrelazamiento en acción</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_009_02/Section_001_desigualdades_de_bell_myst.html">9.1. Desigualdades de Bell</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_009_02/Section_002_experimento_ghz_myst.html">9.2. Experimento GHZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_009_02/Section_003_teleportacion_myst.html">9.3. Teleportación</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_009_02/Section_004_intercambio_de_entrelazamiento_myst.html">9.4. Intercambio de Entrelazamiento</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_009_02/Section_005_teorema_de_no-clonacion__myst.html">9.5. Teorema de no-clonación</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_010_01_hardware_tecnicas_de_control_y_computacion_en_rmn_myst.html">10. Hardware: Técnicas de control y computación en RMN.</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_010_02/Section_001_introduccion_myst.html">10.1. Introducción.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_010_02/Section_002_el_espin_nuclear__myst.html">10.2. El espín nuclear</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_010_02/Section_003_qubits_de_rmn_myst.html">10.3. Qúbits de RMN</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_010_02/Section_004_tecnicas_de_pulsos_elementales__myst.html">10.4. Técnicas de pulsos elementales.</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../Part_03/Chapter_011_01_decoherencia_y_desfase_myst.html">11. Decoherencia y desfase</a><input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-10"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_011_02/Section_001_introduccion_myst.html">11.1. Introducción</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_011_02/Section_002_decoherencia_y_las_ecuaciones_de_bloch_myst.html">11.2. Decoherencia y las ecuaciones de Bloch.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Part_03/Chapter_011_02/Section_003_resumen_myst.html">11.3. Resumen</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Algoritmos Cuánticos</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_012_01_elementos_basicos_de_los_algoritmos_cuanticos_myst.html">12. Elementos básicos de los algoritmos cuánticos</a><input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-11"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_012_02/Section_001_circuitos_myst.html">12.1. Circuitos</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_012_02/Section_002_retroceso_de_fase_phase_kickback_myst.html">12.2. Retroceso de fase (Phase kickback)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_012_02/Section_003_circuitos_equivalentes_myst.html">12.3. Circuitos equivalentes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_012_02/Section_004_operadores_de_clifford_myst.html">12.4. Operadores de Clifford</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_012_02/Section_005_universalidad_de_la_computacion_cuantica_con_puertas__myst.html">12.5. Universalidad de la computación cuántica con puertas.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_012_02/Section_006_medidas_de_calidad_de_un_circuitos_myst.html">12.6. Medidas de calidad de un Circuitos.</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_013_01_estado_inicial_y_oraculos_myst.html">13. Estado inicial y oráculos</a><input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-12"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_013_02/Section_001_preparacion_de_un_estado_inicial_generico_myst.html">13.1. Preparación de un estado inicial genérico</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_013_02/Section_002_oraculos_funciones_digitales_myst.html">13.2. Oráculos (funciones digitales)</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_014_01_primeros_algoritmos_algoritmos_del_oraculo_myst.html">14. Primeros algoritmos: algoritmos del oráculo.</a><input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-13"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_014_02/Section_001_algoritmo_de_deutsch-jozsa_myst.html">14.1. Algoritmo de Deutsch-Jozsa.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_014_02/Section_002_algoritmo_de_bernstein-vazirani_myst.html">14.2. Algoritmo de Bernstein-Vazirani</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_014_02/Section_003_algoritmo_de_simon_myst.html">14.3. Algoritmo de Simon</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_015_01_qft_quantum_fourier_transform__myst.html">15. QFT: Quantum Fourier Transform</a><input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-14"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_015_02/Section_001_la_qft_en_computacion_cuantica_myst.html">15.1. La QFT en computación cuántica</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_015_02/Section_002_intuicion_myst.html">15.2. Intuición</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_015_02/Section_003_circuito_que_implementa_la_qft_myst.html">15.3. Circuito que implementa la QFT.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_015_02/Section_004_complegidad_y_qft_aproximada_myst.html">15.4. Complegidad y QFT aproximada</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_016_01_qpe_estimacion_de_fase_cuantica__myst.html">16. QPE: Estimación de Fase Cuántica</a><input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-15"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_016_02/Section_001_introduccion_myst.html">16.1. Introducción</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_016_02/Section_002_circuito_myst.html">16.2. Circuito</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_016_02/Section_003_formulacion_matematica_myst.html">16.3. Formulación matemática</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_016_02/Section_004_y_si_no_conocemos_el_autoestado_myst.html">16.4. ¿Y si no conocemos el autoestado?</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_017_01_algoritmo_de_shor_periodicity_finding__myst.html">17. Algoritmo de Shor (Periodicity Finding)</a><input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-16"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_017_02/Section_001_introduccion_myst.html">17.1. Introducción.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_017_02/Section_002_hallar_del_periodo_de_una_funcion_period_finding_myst.html">17.2. Hallar del periodo de una función (Period Finding)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_017_02/Section_003_implementacion_ad_hoc_en_qiskit_para_n%3D15_myst.html">17.3. Implementación (ad hoc) en Qiskit para <span class="math notranslate nohighlight">\(N=15\)</span></a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="../Chapter_018_01_algoritmo_de_shor_implementacion_con_2n%2B3_qubit_myst.html">18. Algoritmo de Shor: Implementación con 2n+3 qubit</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-17"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Section_001_la_idea__myst.html">18.1. La idea</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">18.2. Explicación desgranada</a></li>
<li class="toctree-l2"><a class="reference internal" href="Section_003_implementacion_aproximada_de_la_qft_myst.html">18.3. Implementación aproximada de la QFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="Section_004_implementacion_de_las_swap_controladas_myst.html">18.4. Implementación de las SWAP controladas</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_019_01_algoritmo_de_grover_amplificacion_de_amplitud__myst.html">19. Algoritmo de Grover (Amplificación de amplitud)</a><input class="toctree-checkbox" id="toctree-checkbox-18" name="toctree-checkbox-18" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-18"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_001_diccionario_de_notaciones_myst.html">19.1. Diccionario de notaciones</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_002_introduccion_myst.html">19.2. Introducción</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_003_explicacion_geometrica_del_algoritmo__myst.html">19.3. Explicación geométrica del algoritmo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_004_numero_conocido_de_soluciones__myst.html">19.4. Número conocido de soluciones.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_005_numero_desconocido_de_soluciones__myst.html">19.5. Número desconocido de soluciones</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_006_conteo_de_soluciones_quantum_counting__myst.html">19.6. Conteo de soluciones (Quantum counting)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_007_consideraciones_sobre_la_implementacion__myst.html">19.7. Consideraciones sobre la implementacion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_008_distribucion_de_probababilidad_inicial_aleatoria__myst.html">19.8. Distribución de probababilidad inicial aleatoria</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_019_02/Section_009_implementaciones_con_qiskit_myst.html">19.9. Implementaciones con qiskit.</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Chapter_020_01_criptografia_y_quantum_key_distribution_qkd__myst.html">20. Criptografía y Quantum Key Distribution (QKD)</a><input class="toctree-checkbox" id="toctree-checkbox-19" name="toctree-checkbox-19" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-19"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_020_02/Section_001_introduccion_myst.html">20.1. Introducción</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_020_02/Section_002_fundamentos_de_qkd_myst.html">20.2. Fundamentos de QKD</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Chapter_020_02/Section_003_protocolos_de_qkd_tres_familias_myst.html">20.3. Protocolos de QKD: Tres familias</a></li>
</ul>
</li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Referencias</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../Chapter_Bibliografia_myst.html">Bibliografía</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/davidcb98/CICC_UMA" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/davidcb98/CICC_UMA/edit/master/Book/docs/Part_04/Chapter_018_02/Section_002_explicacion_desgranada_myst.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/davidcb98/CICC_UMA/issues/new?title=Issue%20on%20page%20%2Fdocs/Part_04/Chapter_018_02/Section_002_explicacion_desgranada_myst.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../../_sources/docs/Part_04/Chapter_018_02/Section_002_explicacion_desgranada_myst.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Explicación desgranada</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-cuantico-de-suma">18.2.1. Algoritmo cuántico de suma</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#valor-clasico-registro-cuantico-puerta-phi-add-a">18.2.2. Valor clásico + registro cuántico (puerta <span class="math notranslate nohighlight">\(\phi ADD(a)\)</span>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#suma-modulada-puerta-phi-add-a-mod-n">18.2.3. Suma modulada (puerta <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span>)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caso-con-c-1-c-2-1">18.2.3.1. Caso con <span class="math notranslate nohighlight">\(c_1 = c_2 = 1\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caso-con-c-1-0-y-o-c-2-0">18.2.3.2. Caso con <span class="math notranslate nohighlight">\(c_1 = 0\)</span> y/o <span class="math notranslate nohighlight">\(c_2 = 0\)</span>.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiplicacion-modulada-puerta-cmult-a-mod-n">18.2.4. Multiplicación modulada (puerta <span class="math notranslate nohighlight">\(CMULT(a)MOD(N)\)</span>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#puerta-controlada-c-text-u-a">18.2.5. Puerta controlada <span class="math notranslate nohighlight">\(C\text{-}U_a\)</span></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exponencial-modulada-puerta-c-text-u-a-s">18.2.6. Exponencial modulada (puerta <span class="math notranslate nohighlight">\(C\text{-}U_{a^{s}}\)</span>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#circuito-final-con-4n-2-qubits-sin-la-simplificacion-del-registro-de-conteo">18.2.7. Circuito final con <span class="math notranslate nohighlight">\(4n+2\)</span> qúbits (sin la simplificación del registro de conteo)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#circuito-final-con-2n-3-algoritmo-de-estimacion-iterativa-de-fase-ipe">18.2.8. Circuito final con <span class="math notranslate nohighlight">\(2n+3\)</span>. Algoritmo de estimación iterativa de fase (IPE)</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <blockquote>
<div><p>Jul 23, 2024 | 13 min read</p>
</div></blockquote>
<figure class="align-center">
<a class="reference internal image-reference" href="../../../_images/Fig_logo_UMA_scbi20.png"><img alt="../../../_images/Fig_logo_UMA_scbi20.png" src="../../../_images/Fig_logo_UMA_scbi20.png" style="width: 2000px;" /></a>
</figure>
<p><span class="math notranslate nohighlight">\( \newcommand{\bra}[1]{\langle #1|} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\ket}[1]{|#1\rangle} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\branew}[1]{\langle #1|} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\ketnew}[1]{\langle #1|} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\braket}[2]{\langle #1|#2\rangle} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\ketbra}[2]{| #1\rangle \langle #2 |} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\i}{{\color{blue} i}} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\Hil}{{\cal H}} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\cg}[1]{{\rm C}#1} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\lp}{\left(} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\rp}{\right)} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\lc}{\left[} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\rc}{\right]} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\lch}{\left\{} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\rch}{\right\}} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\Lp}{\Bigl(} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\Rp}{\Bigr)} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\Lc}{\Bigl[} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\Rc}{\Bigr]} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\Lch}{\Bigl\{} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\Rch}{\Bigr\}} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\rqa}{\quad \Rightarrow \quad} \)</span>
<span class="math notranslate nohighlight">\( \newcommand{\bm}{\boldsymbol}\)</span></p>
<section class="tex2jax_ignore mathjax_ignore" id="explicacion-desgranada">
<h1><span class="section-number">18.2. </span>Explicación desgranada<a class="headerlink" href="#explicacion-desgranada" title="Permalink to this heading">#</a></h1>
<p>En las siguientes subsecciones vamos ir explicando poco a poco los pasos mencionado en la sección  <a class="reference internal" href="Section_001_la_idea__myst.html#sec-2n-3-la-idea"><span class="std std-numref">18.1</span></a>.</p>
<section id="algoritmo-cuantico-de-suma">
<span id="sec-2n-3-suma"></span><h2><span class="section-number">18.2.1. </span>Algoritmo cuántico de suma<a class="headerlink" href="#algoritmo-cuantico-de-suma" title="Permalink to this heading">#</a></h2>
<p>Como vamos a ir viendo en las siguientes secciones, esta implementación se basa en <b>sumar</b>. En concreto, se parte de la implementación del <b>algoritmo cuántico de suma de Draper</b> <span id="id1">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id28" title="Thomas G. Draper. Addition on a quantum computer. 2000. URL: https://arxiv.org/abs/quant-ph/0008033, doi:10.48550/ARXIV.QUANT-PH/0008033.">22</a>]</span>, que podemos ver en la Fig.  <a class="reference internal" href="#fig-idea-suma"><span class="std std-numref">18.1</span></a></p>
<figure class="align-center" id="fig-idea-suma">
<a class="reference internal image-reference" href="../../../_images/Fig-Addition-Transform.png"><img alt="../../../_images/Fig-Addition-Transform.png" src="../../../_images/Fig-Addition-Transform.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.1 </span><span class="caption-text">Algoritmo cuántico de suma de Draper (en el convenio <b>estándar</b>). Figura tomada de <span id="id2">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id22" title="Stephane Beauregard. Circuit for shor's algorithm using 2n+3 qubits. arXiv preprint quant-ph/0205095, 2002. URL: https://arxiv.org/abs/quant-ph/0205095, doi:10.48550/ARXIV.QUANT-PH/0205095.">6</a>]</span></span><a class="headerlink" href="#fig-idea-suma" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="note admonition">
<p class="admonition-title">Nota importante</p>
<p>Véase que la puerta “Conditional Phase Shif” de la Fig.  <a class="reference internal" href="#fig-idea-suma"><span class="std std-numref">18.1</span></a> es la puerta <span class="math notranslate nohighlight">\(\cg{R_k}\)</span> de la Ec.  <a class="reference internal" href="../Chapter_015_02/Section_003_circuito_que_implementa_la_qft_myst.html#equation-ec-qft-crk">(15.19)</a>. Véase también que estas puertas no son más que puertas <span class="math notranslate nohighlight">\(P(\phi)\)</span> (o <span class="math notranslate nohighlight">\(P_\phi\)</span>) controladas con <span class="math notranslate nohighlight">\(\phi_k =  2\pi i/2^k\)</span>.</p>
</div>
<p>Este algoritmo suma los valores <span class="math notranslate nohighlight">\(a\)</span> y <span class="math notranslate nohighlight">\(b\)</span>. Las entradas del circuito de suma son el <span class="math notranslate nohighlight">\(\bm{n}\)</span> <b>qúbits</b> representando el número <span class="math notranslate nohighlight">\(a\)</span> y <span class="math notranslate nohighlight">\(\bm{n}\)</span> <b>qúbits</b> que contienen la transformada de Fourier de otro número <span class="math notranslate nohighlight">\(b\)</span>, denotada como <span class="math notranslate nohighlight">\(\phi(b)\)</span>, es decir,</p>
<div class="amsmath math notranslate nohighlight" id="equation-7b8a76fe-17a6-4aaf-85dd-429608240df6">
<span class="eqno">(18.7)<a class="headerlink" href="#equation-7b8a76fe-17a6-4aaf-85dd-429608240df6" title="Permalink to this equation">#</a></span>\[\begin{equation}
|\phi (b) \rangle = QFT \, |b \rangle.
\end{equation}\]</div>
<p>El registro que codifica el número <span class="math notranslate nohighlight">\(a\)</span> no cambia, mientras que registro que codifica <span class="math notranslate nohighlight">\(\phi (b)\)</span> pasa a albergar la suma de <span class="math notranslate nohighlight">\(a+b\)</span> en el espacio de Fourier, <span class="math notranslate nohighlight">\(\phi (a+b)\)</span>. Haciendo la transformada inversa se puede recuperar el valor <span class="math notranslate nohighlight">\(a+b\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-6835c7cd-b7d5-4c9d-95f5-0b9c6a33b40c">
<span class="eqno">(18.8)<a class="headerlink" href="#equation-6835c7cd-b7d5-4c9d-95f5-0b9c6a33b40c" title="Permalink to this equation">#</a></span>\[\begin{equation}
QFT^{-1}| \phi (a+b) \rangle = | a+b \rangle
\end{equation}\]</div>
<p>Lo que vamos a ver es como, partiendo de esta implementación del algoritmo de suma podemos construir la exponencial modulada.</p>
<div class="note admonition">
<p class="admonition-title">Nota</p>
<p>No perdamos el objetivo de vista. Nosotros queremos calcular el periodo de la función <span class="math notranslate nohighlight">\(f(x) = a^x \text{mod}N\)</span>, donde <span class="math notranslate nohighlight">\(a&lt;N\)</span> (tomamos además <span class="math notranslate nohighlight">\(b&lt;N\)</span>). Al tener un <span class="math notranslate nohighlight">\(\text{ mod}N\)</span> sabemos que el esta función no puede devolver valores mayores que <span class="math notranslate nohighlight">\(N\)</span>. Tenemos pues que los <span class="math notranslate nohighlight">\(\boldsymbol{n}\)</span> qúbits que dijimos que usamos para codificar <span class="math notranslate nohighlight">\(a\)</span> y <span class="math notranslate nohighlight">\(b\)</span> son el número de qúbits que nos hace falta para codificar <span class="math notranslate nohighlight">\(N\)</span>.</p>
</div>
</section>
<section id="valor-clasico-registro-cuantico-puerta-phi-add-a">
<span id="sec-2n-3-puerta-phiadd-a"></span><h2><span class="section-number">18.2.2. </span>Valor clásico + registro cuántico (puerta <span class="math notranslate nohighlight">\(\phi ADD(a)\)</span>)<a class="headerlink" href="#valor-clasico-registro-cuantico-puerta-phi-add-a" title="Permalink to this heading">#</a></h2>
<p>Nosotros queremos llegar a calcular el periodo de la función <span class="math notranslate nohighlight">\(f(x) = a^x \text{ mod}N\)</span>, donde <span class="math notranslate nohighlight">\(a\)</span> es un valor fijo menor que <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>Como precisamente este valor es fijo, no nos vemos en la necesidad de codificarlo usando un registro cuántico. Podemos pues sustituir los qúbits que codifican <span class="math notranslate nohighlight">\(a\)</span> por bits clásicos. Las puertas controladas pasan entonces a ser puertas controladas clásicamente. Además, como sabemos de antemano el valor de <span class="math notranslate nohighlight">\(a\)</span>, podemos precalcular el producto de las puertas sobre cada qúbit (sumando las fases), aplicando así solo una puerta por qúbit (reducimos la profundidad del circuito).</p>
<figure class="align-center" id="fig-idea-puerta-phiadd-a">
<a class="reference internal image-reference" href="../../../_images/Fig-phiADD(a).png"><img alt="../../../_images/Fig-phiADD%28a%29.png" src="../../../_images/Fig-phiADD%28a%29.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.2 </span><span class="caption-text">Puerta <span class="math notranslate nohighlight">\(\phi ADD(a)\)</span>. Figura tomada de <span id="id3">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id22" title="Stephane Beauregard. Circuit for shor's algorithm using 2n+3 qubits. arXiv preprint quant-ph/0205095, 2002. URL: https://arxiv.org/abs/quant-ph/0205095, doi:10.48550/ARXIV.QUANT-PH/0205095.">6</a>]</span></span><a class="headerlink" href="#fig-idea-puerta-phiadd-a" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Definimos así la puerta <span class="math notranslate nohighlight">\(\bm{\phi ADD(a)}\)</span> (ver Fig.  <a class="reference internal" href="#fig-idea-puerta-phiadd-a"><span class="std std-numref">18.2</span></a>), que <b>suma un valor clásico</b> <span class="math notranslate nohighlight">\(a\)</span> <b>a un registro cuántico que codifica el valor</b> <span class="math notranslate nohighlight">\( \phi(b)\)</span>. La entrada de esta puerta es la transformada de Fourier del registro <span class="math notranslate nohighlight">\(b\)</span>, es decir, <span class="math notranslate nohighlight">\(\phi (b)\)</span>, y la salida es la transformada de Fourier de la suma, <span class="math notranslate nohighlight">\(\phi (a+b)\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-14407657-59c1-4d79-8554-afd10c0e8f98">
<span class="eqno">(18.9)<a class="headerlink" href="#equation-14407657-59c1-4d79-8554-afd10c0e8f98" title="Permalink to this equation">#</a></span>\[\begin{equation}
\boxed{\phi ADD(a) \, |\phi (b) \rangle = |\phi (a+b) \rangle},
\end{equation}\]</div>
<p>Comentamos antes que el número de qúbits <span class="math notranslate nohighlight">\(n\)</span> que usamos para codificar <span class="math notranslate nohighlight">\(a\)</span> y <span class="math notranslate nohighlight">\(b\)</span> es número de qúbits que nos hacen falta para codificar <span class="math notranslate nohighlight">\(N\)</span> (ya que <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b &lt; N\)</span>). Puede darse el caso de que al hacer la suma tengamos un valor mayor que <span class="math notranslate nohighlight">\(N\)</span>, es decir, <span class="math notranslate nohighlight">\(a+b &gt; N\)</span>. Podríamos tener entonces un número mayor que el número más grande que podemos codificar con los <span class="math notranslate nohighlight">\(n\)</span> qúbits de los que partimos. Esto se denomina <b>overflow</b>. Para evitar esto, lo que podemos hacer es añadir un qúbit extra al registro que contiene <span class="math notranslate nohighlight">\(\phi (b)\)</span>. Tenemos pues que <span class="math notranslate nohighlight">\(\bm{\phi(b)}\)</span> <b>es de forma efectiva la transformada de Fourier de un registro de</b> <span class="math notranslate nohighlight">\(\bm{n+1}\)</span> <b>qúbits que contiene un número de</b> <span class="math notranslate nohighlight">\(\bm n\)</span> <b>bits</b>. De esta forma, antes de la suma, <b>el bit más significativos de la transformada de Fourier inversa del registro</b> <span class="math notranslate nohighlight">\(\bm{\phi(b)}\)</span> <b>es siempre</b> <span class="math notranslate nohighlight">\(\bm{|0 \rangle}\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-ec-shor-2n1-qft-bit">
<span class="eqno">(18.10)<a class="headerlink" href="#equation-ec-shor-2n1-qft-bit" title="Permalink to this equation">#</a></span>\[\begin{equation} 
\boxed{\text{el bit más significativo de } \, QFT^{-1}|\phi(b) \rangle = |b \rangle \, \text{ es siempre } \, |0 \rangle}
\end{equation} \]</div>
<p>Podemos además, definir la inversa de esta puerta, es decir, una puerta de resta. La acción de esta última se recoge en la Fig.  <a class="reference internal" href="#fig-idea-resta"><span class="std std-numref">18.3</span></a> (<b>véase que la puerta de suma tiene la barra negra a la derecha y la de resta a la izquierda</b>). En esta figura <span class="math notranslate nohighlight">\(p\)</span> <b>es un número <span class="math notranslate nohighlight">\(n\)</span> bit</b> y <b><span class="math notranslate nohighlight">\(g\)</span> un número <span class="math notranslate nohighlight">\({n+1}\)</span> bit</b>.</p>
<p>Véase que tenemos resultados diferentes si <span class="math notranslate nohighlight">\(g \geq p \)</span> o <span class="math notranslate nohighlight">\(g &lt; p\)</span>. Precisamente,usando  <a class="reference internal" href="#equation-ec-shor-2n1-qft-bit">(18.10)</a> podemos usar esto para saber cual de los dos números es mayor:</p>
<ul class="simple">
<li><p>Si después de la resta el bit más significativo es <span class="math notranslate nohighlight">\(|0 \rangle\)</span>, estamos en el caso de <span class="math notranslate nohighlight">\(g \geq p\)</span> (solo si <span class="math notranslate nohighlight">\(g-p\)</span> es <span class="math notranslate nohighlight">\(n\)</span> bit).</p></li>
<li><p>Si después de la resta el bit más significativo es <span class="math notranslate nohighlight">\(|1 \rangle\)</span>, estamos en el caso de <span class="math notranslate nohighlight">\(p&gt;g\)</span>.</p></li>
</ul>
<figure class="align-center" id="fig-idea-resta">
<a class="reference internal image-reference" href="../../../_images/Fig-phiADD(a)^-1.png"><img alt="../../../_images/Fig-phiADD%28a%29%5E-1.png" src="../../../_images/Fig-phiADD%28a%29%5E-1.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.3 </span><span class="caption-text">Puerta <span class="math notranslate nohighlight">\(\phi ADD^{-1}(a)\)</span>, es decir, la puerta inversa de <span class="math notranslate nohighlight">\(\phi ADD(a)\)</span>, una puerta de resta. Figura tomada de <span id="id4">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id22" title="Stephane Beauregard. Circuit for shor's algorithm using 2n+3 qubits. arXiv preprint quant-ph/0205095, 2002. URL: https://arxiv.org/abs/quant-ph/0205095, doi:10.48550/ARXIV.QUANT-PH/0205095.">6</a>]</span></span><a class="headerlink" href="#fig-idea-resta" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<div class="note admonition">
<p class="admonition-title">Nota</p>
<p>Aplicaremos este método con:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(p = N \quad\)</span> y <span class="math notranslate nohighlight">\(\quad g = b, \, a+b \quad\)</span> (parte 1 en la Fig.  <a class="reference internal" href="#fig-idea-puerta-phiadd-a-mod-n"><span class="std std-numref">18.4</span></a>)</p></li>
<li><p><span class="math notranslate nohighlight">\(p = \, a \, \quad\)</span> y <span class="math notranslate nohighlight">\(\quad g = b, \, a+b, \, a+b - N \quad\)</span>   (parte 2 en la Fig.  <a class="reference internal" href="#fig-idea-puerta-phiadd-a-mod-n"><span class="std std-numref">18.4</span></a>)</p></li>
</ul>
<p>En ambos casos tenemos que <span class="math notranslate nohighlight">\(p\)</span> es un número <span class="math notranslate nohighlight">\(n\)</span> bit y si <span class="math notranslate nohighlight">\(g \geq p\)</span> tenemos <span class="math notranslate nohighlight">\(g-p &lt; N\)</span>, así que <span class="math notranslate nohighlight">\(g-p\)</span> es <span class="math notranslate nohighlight">\(n\)</span> bit. Podemos pues aplicar el criterio del bit más significativo para saber que número es más grande.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Nota (<span class="math notranslate nohighlight">\(\phi ADD(p)\)</span> y <span class="math notranslate nohighlight">\(\phi ADD^{-1}(p)\)</span> son una la inversa de la otra)</p>
<div class="amsmath math notranslate nohighlight" id="equation-3c5dc5c9-4bfc-4130-bd97-9a048239f313">
<span class="eqno">(18.11)<a class="headerlink" href="#equation-3c5dc5c9-4bfc-4130-bd97-9a048239f313" title="Permalink to this equation">#</a></span>\[\begin{equation}
\phi ADD^{-1}(p) \, | \phi(g) \rangle = |\phi (2^{n+1} - (p-g)) \rangle
\end{equation}\]</div>
<p>Si ahora sumamos otra vez <span class="math notranslate nohighlight">\(p\)</span> tenemos:</p>
<div class="amsmath math notranslate nohighlight" id="equation-122b2f1e-fe9e-4bce-9482-1567ccd4d924">
<span class="eqno">(18.12)<a class="headerlink" href="#equation-122b2f1e-fe9e-4bce-9482-1567ccd4d924" title="Permalink to this equation">#</a></span>\[\begin{equation}
\phi ADD(p) \, |\phi (2^{n+1} - (p-g)) \rangle =  |\phi (2^{n+1} - (p-g)) + p \rangle =  |\phi (2^{n+1} + g)) \rangle
\end{equation}\]</div>
<p>Como <span class="math notranslate nohighlight">\(2^{n+1} + g\)</span> es mayor que el valor máximo que podemos almacenar con <span class="math notranslate nohighlight">\(n+1\)</span> qúbits, tenemos overflow:</p>
<div class="amsmath math notranslate nohighlight" id="equation-07157e11-cb36-4961-be97-c12c5d96b550">
<span class="eqno">(18.13)<a class="headerlink" href="#equation-07157e11-cb36-4961-be97-c12c5d96b550" title="Permalink to this equation">#</a></span>\[\begin{equation}
\phi ADD(p) \, |\phi (2^{n+1} - (p-g)) \rangle = |\phi (2^{n+1} + g)) \rangle = |\phi (g) \rangle
\end{equation}\]</div>
<p>Con lo cual, efectivamente, <span class="math notranslate nohighlight">\(\phi ADD(p)\)</span> y <span class="math notranslate nohighlight">\(\phi ADD^{-1}(p)\)</span> son una la inversa de la otra.</p>
</div>
</section>
<section id="suma-modulada-puerta-phi-add-a-mod-n">
<span id="sec-2n-3-puerta-phiadd-a-mod-n"></span><h2><span class="section-number">18.2.3. </span>Suma modulada (puerta <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span>)<a class="headerlink" href="#suma-modulada-puerta-phi-add-a-mod-n" title="Permalink to this heading">#</a></h2>
<p>Un vez definida la puerta de suma <span class="math notranslate nohighlight">\(\phi ADD(a)\)</span>, podemos usarla para construir una puerta de <b>suma modulada</b> <span class="math notranslate nohighlight">\(\bm{\phi ADD(a)MOD(N)}\)</span> (ver Fig.  <a class="reference internal" href="#fig-idea-puerta-phiadd-a-mod-n"><span class="std std-numref">18.4</span></a>). Esta puerta suma <span class="math notranslate nohighlight">\(a+b\)</span> y le resta <span class="math notranslate nohighlight">\(N\)</span> si <span class="math notranslate nohighlight">\(a+b \geq N\)</span>. Las entradas de la misma son <span class="math notranslate nohighlight">\(\phi(b)\)</span> con <span class="math notranslate nohighlight">\(b &lt; N\)</span> y un valor clásico <span class="math notranslate nohighlight">\(a &lt; N\)</span>.</p>
<div class="amsmath math notranslate nohighlight" id="equation-8e5f4053-5d91-4b0c-a700-ce904606f64e">
<span class="eqno">(18.14)<a class="headerlink" href="#equation-8e5f4053-5d91-4b0c-a700-ce904606f64e" title="Permalink to this equation">#</a></span>\[\begin{equation}
\boxed{\phi ADD(a)MOD(N) |\phi (b) \rangle = |\phi \left( (a+b) \text{ mod} N \right)\rangle}  = \,  QFT \, | (a+b) \text{ mod} N \rangle
\end{equation}\]</div>
<figure class="align-center" id="fig-idea-puerta-phiadd-a-mod-n">
<a class="reference internal image-reference" href="../../../_images/Fig-phiADD(a)MOD(N).png"><img alt="../../../_images/Fig-phiADD%28a%29MOD%28N%29.png" src="../../../_images/Fig-phiADD%28a%29MOD%28N%29.png" style="width: 1000px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.4 </span><span class="caption-text">Puerta <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span> (en el convenio de <b>Qiskit</b>). Figura tomada de <span id="id5">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id22" title="Stephane Beauregard. Circuit for shor's algorithm using 2n+3 qubits. arXiv preprint quant-ph/0205095, 2002. URL: https://arxiv.org/abs/quant-ph/0205095, doi:10.48550/ARXIV.QUANT-PH/0205095.">6</a>]</span>.</span><a class="headerlink" href="#fig-idea-puerta-phiadd-a-mod-n" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>En la Fig.  <a class="reference internal" href="#fig-idea-puerta-phiadd-a-mod-n"><span class="std std-numref">18.4</span></a> vemos que se han añadido dos qúbits de control (<span class="math notranslate nohighlight">\(| c_1 \rangle\)</span>, <span class="math notranslate nohighlight">\(| c_2 \rangle\)</span>) para futuros usos. La puerta solo se activa si <span class="math notranslate nohighlight">\(c_1 = c_2 = 1\)</span>. Se han numerado las puertas (cuadros rojos) para facilitar la explicación.</p>
<p>Como podemos ver en la imagen, el circuito que implementa esta puerta tiene dos parte:</p>
<ul class="simple">
<li><p>Parte 1: Calcula <span class="math notranslate nohighlight">\((a+b) \text{ mod} N\)</span>.</p></li>
<li><p>Parte 2: Vuelve a poner en el estado <span class="math notranslate nohighlight">\(|0 \rangle\)</span> el qúbit ancila (el qúbit de abajo del todo en la imagen).</p></li>
</ul>
<div class="note admonition">
<p class="admonition-title">Nota</p>
<p>Un qúbit <b>ancila</b> es un qúbit auxiliar que se usa para hacer un calculo intermedio pero que no forma parte de la solución. Estos qúbit hay que volver a ponerlos en el estado inicial.</p>
</div>
<div class="note admonition">
<p class="admonition-title">Nota importante</p>
<p>El qúbit ancila <b>no es qúbit extra del registro</b> <span class="math notranslate nohighlight">\(| \phi (b) \rangle\)</span>. Tenemos pues los 2 qúbits de control, los <span class="math notranslate nohighlight">\(n+1\)</span> de la entrada <span class="math notranslate nohighlight">\(| \phi (b) \rangle\)</span> y el qúbit de la ancila, con lo cual usamos <span class="math notranslate nohighlight">\(n+4\)</span> qúbits.</p>
</div>
<p>Veamos todos los posibles casos que nos podemos encontrar el aplicar el circuito de la Fig  <a class="reference internal" href="#fig-idea-puerta-phiadd-a-mod-n"><span class="std std-numref">18.4</span></a>.</p>
<section id="caso-con-c-1-c-2-1">
<h3><span class="section-number">18.2.3.1. </span>Caso con <span class="math notranslate nohighlight">\(c_1 = c_2 = 1\)</span><a class="headerlink" href="#caso-con-c-1-c-2-1" title="Permalink to this heading">#</a></h3>
<p>Partimos del estado <span class="math notranslate nohighlight">\(| \phi(b) \rangle\)</span>.</p>
<ul>
<li><p><b>Puerta 1</b>: Después de aplicar la puerta 1 (puerta <span class="math notranslate nohighlight">\(\phi ADD(a)\)</span>) tenemos el estado <span class="math notranslate nohighlight">\(| \phi(a+b) \rangle\)</span>.</p></li>
<li><p><b>Puertas 2, 3, 4 y 5</b>: Lo que vamos a hacer con estas puestas es ver si estamos en el caso de <span class="math notranslate nohighlight">\(a+b \geq N\)</span> o <span class="math notranslate nohighlight">\(a+b &lt;N\)</span>. Para ello, aplicamos una puerta <span class="math notranslate nohighlight">\(\phi ADD^{-1}(N)\)</span> (puerta 2), con lo cual tenemos:</p>
<ol class="arabic simple">
<li><p>El estado <span class="math notranslate nohighlight">\(| \phi(a+b - N) \rangle\)</span> si <span class="math notranslate nohighlight">\(a+b \geq N\)</span>.</p></li>
<li><p>El estado <span class="math notranslate nohighlight">\(| \phi(2^{n+1} -(a+b - N)) \rangle\)</span> si <span class="math notranslate nohighlight">\(a+b &lt; N\)</span>.</p></li>
</ol>
<p>Las puertas 3, 4 y 5 lo que hacen es poner el qúbit ancila a 1 si el bit más significativo es 1, es decir, si estamos en el segundo caso.</p>
</li>
<li><p><b>Puerta 6</b>: Esta puerta solo se activa si la ancila es 1, es decir, si estamos en el segundo caso del paso anterior (<span class="math notranslate nohighlight">\(a+b &lt; N\)</span>). Esta puerta lo que hace es sumar <span class="math notranslate nohighlight">\(N\)</span>, deshaciendo la resta de la puerta 2 si estamos en el caso <span class="math notranslate nohighlight">\(a+b &lt; N\)</span>, es decir, si no teníamos que haber restado <span class="math notranslate nohighlight">\(N\)</span>. Después de esta puerta ya tenemos el resultado de la suma modulada. Solo nos queda limpiar la ancila.</p></li>
<li><p>Puerta 7: Partimos del valor <span class="math notranslate nohighlight">\((a+b) \text{ mod} N\)</span>. Con esta puerta restamos <span class="math notranslate nohighlight">\(a\)</span>, con lo cual tenemos dos casos.</p>
<ol class="arabic simple" start="3">
<li><p>Si  <span class="math notranslate nohighlight">\((a+b) &gt; N \quad \Rightarrow \quad (a+b) \text{ mod} N = a+b-N &lt; a \quad \Rightarrow \)</span>
<span class="math notranslate nohighlight">\(\qquad \quad \Rightarrow \quad \phi ADD^{-1}(a) \, | \phi ((a+b) \text{ mod} N) \rangle = | \phi ( 2^{n+1} - (N - b) ) \rangle\)</span></p></li>
<li><p>Si <span class="math notranslate nohighlight">\((a+b) &lt; N \quad \Rightarrow \quad (a+b) \text{ mod} N = a+b &gt; a \quad \Rightarrow \)</span>
<span class="math notranslate nohighlight">\(\qquad \quad \Rightarrow \quad \phi ADD^{-1}(a) \, | \phi ((a+b) \text{ mod} N) \rangle = | \phi ( b ) \rangle\)</span></p></li>
</ol>
</li>
<li><p><b>Puertas 8, 9, 10, 11, 12</b>: Estas puertas lo que hacen es cambiar la ancila si el bit más significativo es cero. Vemos que este es el caso 4 del paso anterior, es decir, cuando <span class="math notranslate nohighlight">\((a+b) &lt; N\)</span>. Si nos fijamos en cuando aplicamos las puertas 2, 3, 4 y 5, esto corresponde al caso 2, justo aquel en el que cambiamos la ancila. Es decir, si hubiéramos cambiado la ancila, ahora la habríamos vuelto a poner a cero.</p></li>
<li><p><b>Puerta 13</b>: Deshace el cambio producido por la puerta 7.</p></li>
</ul>
</section>
<section id="caso-con-c-1-0-y-o-c-2-0">
<h3><span class="section-number">18.2.3.2. </span>Caso con <span class="math notranslate nohighlight">\(c_1 = 0\)</span> y/o <span class="math notranslate nohighlight">\(c_2 = 0\)</span>.<a class="headerlink" href="#caso-con-c-1-0-y-o-c-2-0" title="Permalink to this heading">#</a></h3>
<p>En estos casos la puerta <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span> deja invariante la entrada. Partimos del estado <span class="math notranslate nohighlight">\(| \phi(b) \rangle\)</span>.</p>
<ul class="simple">
<li><p><b>Puerta 1</b>: No se aplica.</p></li>
<li><p><b>Puerta 2</b>: Restamos <span class="math notranslate nohighlight">\(N\)</span>, con lo cual pasamos a tener <span class="math notranslate nohighlight">\(\phi \left( 2^{n+1} - (N-b) \right)\)</span>.</p></li>
<li><p><b>Puertas 2, 3, 4 y 5</b>: Como el bit más significativo en este caso es siempre 1, estas puertas ponen la ancila a 1.</p></li>
<li><p><b>Puerta 6</b>: Como la ancila es 1, esta puerta se activa y deshace los cambios de la puerta 2. Pasamos pues a tener el estado inicial <span class="math notranslate nohighlight">\(| \phi(b) \rangle\)</span> pero con la ancila a 1.</p></li>
<li><p><b>Puerta 7</b>: No se aplica.</p></li>
<li><p><b>Puertas 8, 9, 10, 11, 12</b>: Como comentamos antes, estas puertas cambian la ancila si el estado que entra tiene el bit más significativo a cero. Como tenemos el estado <span class="math notranslate nohighlight">\(| \phi(b) \rangle\)</span>, este es nuestro caso así que se vuelve a cambiar la ancila. Pasamos pues a tener el estado inicial, sin ningún cambio.</p></li>
<li><p><b>Puerta 13</b>: No se aplica.</p></li>
</ul>
</section>
</section>
<section id="multiplicacion-modulada-puerta-cmult-a-mod-n">
<span id="sec-2n-3-puerta-cmult-a-mod-n"></span><h2><span class="section-number">18.2.4. </span>Multiplicación modulada (puerta <span class="math notranslate nohighlight">\(CMULT(a)MOD(N)\)</span>)<a class="headerlink" href="#multiplicacion-modulada-puerta-cmult-a-mod-n" title="Permalink to this heading">#</a></h2>
<p>El siguiente paso es usar la puerta <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span> para construir una
puerta controlada de multiplicación modulada que denominaremos como <span class="math notranslate nohighlight">\(CMULT(a)MOD(N)\)</span>. La entrada de esta puerta serán tres registros <span class="math notranslate nohighlight">\(|c \rangle |x \rangle |b  \rangle\)</span>, donde <span class="math notranslate nohighlight">\(|c \rangle\)</span> es un qúbit controlador:</p>
<div class="amsmath math notranslate nohighlight" id="equation-9241f3d6-3664-4a10-9307-b6bba5d1357b">
<span class="eqno">(18.15)<a class="headerlink" href="#equation-9241f3d6-3664-4a10-9307-b6bba5d1357b" title="Permalink to this equation">#</a></span>\[\begin{equation}
\boxed{CMULT(a)MOD(N) \, |c \rangle |x \rangle |b \rangle = |c \rangle |x \rangle | (b + a x) \text{ mod} N \rangle, \qquad \, \text{si }   c = 1}
\end{equation}\]</div>
<div class="amsmath math notranslate nohighlight" id="equation-eb75a90c-990c-4840-bdac-67d9039c1d80">
<span class="eqno">(18.16)<a class="headerlink" href="#equation-eb75a90c-990c-4840-bdac-67d9039c1d80" title="Permalink to this equation">#</a></span>\[\begin{equation}
CMULT(a)MOD(N) \, |c \rangle |x \rangle |b \rangle = |c \rangle |x \rangle | b \rangle, \qquad  \text{si }  c = 0
\end{equation}\]</div>
<p>Para implementar esta puerta recurrimos a las puertas <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span> de la sección anterior y a la identidad</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
(ax) \text{mod} N &amp; = (2^0 a x_0 + 2^1 a x_1 + \dots + 2^{n-1} a x_{n-1}) \text{mod} N \\
&amp; = \Lch \dots \Lc (2^0 a x_0) \text{mod} N + 2^1 a x_1 \Rc \text{mod} N + \dots + 2^{n-1} a x_{n-1} \Rch \text{mod} N
\end{align*}\]</div>
<p>Es fácil entender esta identidad: es lo mismo sumar todos los términos y finalmente tomar el módulo de la suma completa que tomar el módulo del primer termino, sumárselo al segundo término, volver a tomar el módulo, etc.</p>
<p>Vemos que esto se puede implementar aplicando:</p>
<ul class="simple">
<li><p>primero una puerta <span class="math notranslate nohighlight">\(\phi ADD(2^0 a) MOD(N)\)</span> sobre <span class="math notranslate nohighlight">\(|b \rangle\)</span> controlada por <span class="math notranslate nohighlight">\(|c \rangle\)</span> y <span class="math notranslate nohighlight">\(| x_0 \rangle \)</span>,</p></li>
<li><p>después una puerta <span class="math notranslate nohighlight">\(\phi ADD(2^1 a) MOD(N)\)</span> sobre el resultado de la anterior controlada por <span class="math notranslate nohighlight">\(|c \rangle\)</span> y <span class="math notranslate nohighlight">\(| x_1 \rangle\)</span>, etc.</p></li>
</ul>
<p>Con lo cual, <b>solo necesitamos aplicar <span class="math notranslate nohighlight">\(n\)</span> puertas doblemente controladas <span class="math notranslate nohighlight">\(\phi ADD (2^i a) MOD(N)\)</span></b> con <span class="math notranslate nohighlight">\(0 \leq i &lt; N\)</span>. Podemos ver esta implementación en la  Fig.  <a class="reference internal" href="#fig-idea-cmult-a-mod-n"><span class="std std-numref">18.5</span></a>.</p>
<figure class="align-center" id="fig-idea-cmult-a-mod-n">
<a class="reference internal image-reference" href="../../../_images/Fig-CMULT(a)MOD(N).png"><img alt="../../../_images/Fig-CMULT%28a%29MOD%28N%29.png" src="../../../_images/Fig-CMULT%28a%29MOD%28N%29.png" style="width: 900px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.5 </span><span class="caption-text">Puerta <span class="math notranslate nohighlight">\(CMULT(a)MOD(N)\)</span> (en el convenio de <b>Qiskit</b>). Figura tomada de <span id="id6">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id22" title="Stephane Beauregard. Circuit for shor's algorithm using 2n+3 qubits. arXiv preprint quant-ph/0205095, 2002. URL: https://arxiv.org/abs/quant-ph/0205095, doi:10.48550/ARXIV.QUANT-PH/0205095.">6</a>]</span>.</span><a class="headerlink" href="#fig-idea-cmult-a-mod-n" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="puerta-controlada-c-text-u-a">
<span id="sec-2n-3-puerta-c-u-a"></span><h2><span class="section-number">18.2.5. </span>Puerta controlada <span class="math notranslate nohighlight">\(C\text{-}U_a\)</span><a class="headerlink" href="#puerta-controlada-c-text-u-a" title="Permalink to this heading">#</a></h2>
<p>En la sección anterior vimos como construir una puerta controlada que aplica la operación</p>
<div class="amsmath math notranslate nohighlight" id="equation-5bb54c71-e40f-4918-ac5e-722bed5b981a">
<span class="eqno">(18.17)<a class="headerlink" href="#equation-5bb54c71-e40f-4918-ac5e-722bed5b981a" title="Permalink to this equation">#</a></span>\[\begin{equation}
| x \rangle | b \rangle \quad \rightarrow \quad |x \rangle | (b+ax) \text{ mod}N \rangle
\end{equation}\]</div>
<p>Pero esto no es lo que queremos, nosotros queremos una puerta controlada que nos lleve el estado <span class="math notranslate nohighlight">\(|x \rangle\)</span> al estado <span class="math notranslate nohighlight">\(| (ax) \text{ mod} \rangle\)</span>. Lo que podemos hacer para solventar esto es lo siguiente:</p>
<ul>
<li><p>Aplicar primero una puerta <span class="math notranslate nohighlight">\(CMULT(a)MOD(N)\)</span> sobre el estado <span class="math notranslate nohighlight">\(|c\rangle |x \rangle |0 \rangle\)</span>, con lo cual obtenemos el estado <span class="math notranslate nohighlight">\(|c \rangle |x \rangle | (ax) \text{ mod} N \rangle\)</span>.</p></li>
<li><p>A continuación, si <span class="math notranslate nohighlight">\(|c \rangle = | 1 \rangle\)</span> aplicamos puertas SWAP controladas  para cambiar los registros <span class="math notranslate nohighlight">\(|x \rangle\)</span> y <span class="math notranslate nohighlight">\(|(b + ax) \text{ mod} N \rangle\)</span>, con lo cual pasamos a tener el estado <span class="math notranslate nohighlight">\(|c \rangle |(ax) \text{ mod} N \rangle |x \rangle \)</span>. Solo necesitamos aplicar puertas controladas SWAP a <span class="math notranslate nohighlight">\(n\)</span> qúbits, no a <span class="math notranslate nohighlight">\(n+1\)</span>, ya que el qúbit más significativo de <span class="math notranslate nohighlight">\((ax) \text{ mod}N\)</span> es siempre 0, ya que es el qúbit extra que incluimos para evitar overflow en las puertas <span class="math notranslate nohighlight">\(\phi ADD (a)\)</span>.</p></li>
<li><p>Finalmente, aplicamos la inversa de la puerta controlada <span class="math notranslate nohighlight">\(CMULT(a^{-1}) MOD(N)\)</span> (donde <span class="math notranslate nohighlight">\(a^{-1}\)</span> es el inverso de <span class="math notranslate nohighlight">\(a\)</span> mod<span class="math notranslate nohighlight">\(N\)</span>), para poner el tercer registro a <span class="math notranslate nohighlight">\(\ket{0}\)</span> otra vez. Este valor se calcula clásicamente en tiempo polinómico usando el algoritmo de Euclides y tenemos asegurado que siempre existe ya que <span class="math notranslate nohighlight">\(gcd(a,N) =1\)</span>. En resumen, si la entrada de esta puerta es el estado <span class="math notranslate nohighlight">\(|c \rangle | x \rangle | b \rangle\)</span> con <span class="math notranslate nohighlight">\(|c \rangle = |1 \rangle\)</span> tenemos:</p>
<div class="amsmath math notranslate nohighlight" id="equation-d9358ddc-e2db-471e-ab7f-cff43c03aee6">
<span class="eqno">(18.18)<a class="headerlink" href="#equation-d9358ddc-e2db-471e-ab7f-cff43c03aee6" title="Permalink to this equation">#</a></span>\[\begin{equation}
    \boxed{[CMULT(a^{-1}) MOD(N)]^{-1} |c \rangle | x \rangle | b \rangle = |c \rangle | x \rangle | (b - a^{-1}x \rangle}
    \end{equation}\]</div>
<p>En nuestro caso tenemos que el estado de entrada es <span class="math notranslate nohighlight">\(|c \rangle |(ax) \text{ mod} N \rangle |x \rangle \)</span>, con lo cual:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
    [CMULT(a^{-1}) MOD(N)]^{-1} |c \rangle |(ax) \text{ mod} N \rangle |x \rangle &amp; = |c \rangle |(ax) \text{ mod} N \rangle |(x - a^{-1} ax )\text{ mod} N \rangle = \\
    &amp; = |c \rangle |(ax) \text{ mod} N \rangle | 0 \rangle
    \end{align*}\]</div>
</li>
</ul>
<p>Denominaremos al conjunto de aplicar estas tres puertas controladas la puerta controlada <span class="math notranslate nohighlight">\(\bm{U_a}\)</span>, es decir, <span class="math notranslate nohighlight">\(C\text{-}U_a\)</span>. En resumen, esta puerta lo que hace es tomar como entrada <span class="math notranslate nohighlight">\(| c \rangle | x \rangle |0 \rangle\)</span> y devolver  <span class="math notranslate nohighlight">\(| c \rangle | (ax) \text{ mod} N  \rangle |0 \rangle\)</span> si <span class="math notranslate nohighlight">\(c=1\)</span>:</p>
<div class="amsmath math notranslate nohighlight" id="equation-5af604da-3d5f-4c1d-add8-e8fee33acc72">
<span class="eqno">(18.19)<a class="headerlink" href="#equation-5af604da-3d5f-4c1d-add8-e8fee33acc72" title="Permalink to this equation">#</a></span>\[\begin{equation}
\boxed{C\text{-}U_a | c \rangle | x \rangle |0 \rangle = | c \rangle | (ax) \text{ mod} N  \rangle |0 \rangle \qquad \text{ si } c = 1}
\end{equation}\]</div>
<p>Si <span class="math notranslate nohighlight">\(c=0\)</span>, aplica la identidad.</p>
<p>Para resumir, si <span class="math notranslate nohighlight">\(|c \rangle = | 1 \rangle\)</span> los pasos que hace la puerta <span class="math notranslate nohighlight">\(C\text{-}U_a\)</span> son los siguientes (ver Fig.  <a class="reference internal" href="#fig-idea-c-u-a"><span class="std std-numref">18.6</span></a>)</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
&amp; | x \rangle | 0 \rangle  \quad \rightarrow \quad |x \rangle | (ax) \text{ mod}N \rangle \quad \rightarrow \quad  | (ax) \text{ mod}N \rangle |x \rangle \quad \rightarrow \\
&amp;\rightarrow \quad | (ax) \text{ mod}N \rangle  | (x - a^{-1}ax) \text{ mod}N \rangle = | (ax) \text{ mod}N \rangle | 0\rangle
\end{align*}\]</div>
<p>Si nos fijamos, el último registro, al estar a <span class="math notranslate nohighlight">\(|0 \rangle\)</span> al inicio y al final, podemos considerarlo parte de la puerta <span class="math notranslate nohighlight">\(C\text{-}U_{a}\)</span> (una ancila):</p>
<div class="amsmath math notranslate nohighlight" id="equation-0be8bf51-0c93-42e9-be89-442595d558c8">
<span class="eqno">(18.20)<a class="headerlink" href="#equation-0be8bf51-0c93-42e9-be89-442595d558c8" title="Permalink to this equation">#</a></span>\[\begin{equation}
C\text{-}U_a | x \rangle |0\rangle = |(ax) \text{ mod} N \rangle |0 \rangle \quad \Rightarrow \quad \boxed{C\text{-}U_a | x \rangle  = |(ax) \text{ mod} N \rangle}
\end{equation}\]</div>
<figure class="align-center" id="fig-idea-c-u-a">
<a class="reference internal image-reference" href="../../../_images/Fig-C-U_a.png"><img alt="../../../_images/Fig-C-U_a.png" src="../../../_images/Fig-C-U_a.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.6 </span><span class="caption-text">Puerta <span class="math notranslate nohighlight">\(C\text{-}U_a\)</span></span><a class="headerlink" href="#fig-idea-c-u-a" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="exponencial-modulada-puerta-c-text-u-a-s">
<span id="sec-2n-3-puerta-c-u-a-s"></span><h2><span class="section-number">18.2.6. </span>Exponencial modulada (puerta <span class="math notranslate nohighlight">\(C\text{-}U_{a^{s}}\)</span>)<a class="headerlink" href="#exponencial-modulada-puerta-c-text-u-a-s" title="Permalink to this heading">#</a></h2>
<p>Una vez construida la puerta <span class="math notranslate nohighlight">\(C\text{-}U_{a}\)</span> uno podría pensar que para aplicar la exponencial modulada lo que hay que hacer es aplicar varias veces esta puerta, es decir:</p>
<div class="amsmath math notranslate nohighlight" id="equation-fef6fe4a-7010-446a-ae02-e38733fbb842">
<span class="eqno">(18.21)<a class="headerlink" href="#equation-fef6fe4a-7010-446a-ae02-e38733fbb842" title="Permalink to this equation">#</a></span>\[\begin{equation}
\left( C\text{-}U_a \right)^s  | x \rangle  = |(a^s x) \text{ mod} N \rangle
\end{equation}\]</div>
<p>Aunque esta implementación es posible, tenemos la opción de hacer una mucho más optima. Para ello nos servimos de la propiedad</p>
<div class="amsmath math notranslate nohighlight" id="equation-82f64aec-a610-4c89-ae5e-42da35dfc28b">
<span class="eqno">(18.22)<a class="headerlink" href="#equation-82f64aec-a610-4c89-ae5e-42da35dfc28b" title="Permalink to this equation">#</a></span>\[\begin{equation}
(a^s x) \text{ mod} N = \underbrace{\{ \dots [a(ax) \text{ mod}N] \text{ mod}N \dots \}\text{ mod}{N}}_{s \text{ veces}} = [x (a^s)\text{ mod}N ] \text{ mod}N
\end{equation}\]</div>
<p>En vez de aplicar <span class="math notranslate nohighlight">\(s\)</span> veces la puerta <span class="math notranslate nohighlight">\(C\text{-}U_{a}\)</span> podemos aplicar una sola vez la puerta <span class="math notranslate nohighlight">\(C\text{-}U_{a^s}\)</span> donde el subíndice <span class="math notranslate nohighlight">\(a^s\)</span> hace referencia que le pasamos a la puerta el valor <span class="math notranslate nohighlight">\(a^s \text{ mod} N\)</span> (este se calcula clásicamente)</p>
<div class="amsmath math notranslate nohighlight" id="equation-fca30d6b-e99e-4ea5-90b2-b0d6d59e028a">
<span class="eqno">(18.23)<a class="headerlink" href="#equation-fca30d6b-e99e-4ea5-90b2-b0d6d59e028a" title="Permalink to this equation">#</a></span>\[\begin{equation}
C\text{-}U_{a^{s}} = (C\text{-}U_{a})^s
\end{equation}\]</div>
</section>
<section id="circuito-final-con-4n-2-qubits-sin-la-simplificacion-del-registro-de-conteo">
<span id="sec-2n-3-circuito-final-no-simplificacion"></span><h2><span class="section-number">18.2.7. </span>Circuito final con <span class="math notranslate nohighlight">\(4n+2\)</span> qúbits (sin la simplificación del registro de conteo)<a class="headerlink" href="#circuito-final-con-4n-2-qubits-sin-la-simplificacion-del-registro-de-conteo" title="Permalink to this heading">#</a></h2>
<p>Solo nos queda ver el circuito con la implementación completa del algoritmo de Shor, representado en la Fig.  <a class="reference internal" href="#fig-idea-circ-final-no-simpli"><span class="std std-numref">18.7</span></a>. (Recordemos que <span class="math notranslate nohighlight">\(n\)</span> es el número de qúbits que necesitamos para codificar <span class="math notranslate nohighlight">\(n\)</span> y que en el registro de conteo necesitamos <span class="math notranslate nohighlight">\(2n\)</span> qúbits.)</p>
<figure class="align-center" id="fig-idea-circ-final-no-simpli">
<a class="reference internal image-reference" href="../../../_images/Fig-Circuito-paper.png"><img alt="../../../_images/Fig-Circuito-paper.png" src="../../../_images/Fig-Circuito-paper.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.7 </span><span class="caption-text">Circuito final con <span class="math notranslate nohighlight">\(4n+2\)</span> qúbits sin la simplificación del registro de conteo (en el convenio estándar).</span><a class="headerlink" href="#fig-idea-circ-final-no-simpli" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Esta implementación usa <span class="math notranslate nohighlight">\(4n+2\)</span> qúbits:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(2n\)</span> qúbits en el registro de conteo</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span> qúbits para el estado <span class="math notranslate nohighlight">\(|1\rangle\)</span> (este es, el estado <span class="math notranslate nohighlight">\(|x \rangle\)</span> de las secciones  <a class="reference internal" href="#sec-2n-3-puerta-cmult-a-mod-n"><span class="std std-numref">18.2.4</span></a> a la  <a class="reference internal" href="#sec-2n-3-puerta-c-u-a"><span class="std std-numref">18.2.5</span></a>.</p></li>
<li><p><span class="math notranslate nohighlight">\(n+2\)</span> qúbits para las ancilas:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(n+1\)</span> qúbits para el estado <span class="math notranslate nohighlight">\(|b \rangle = | 0 \rangle\)</span> (ver Figs.  <a class="reference internal" href="#fig-idea-cmult-a-mod-n"><span class="std std-numref">18.5</span></a> y  <a class="reference internal" href="#fig-idea-c-u-a"><span class="std std-numref">18.6</span></a>).</p></li>
<li><p>1 qúbit para la ancila de la puerta <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span> (ver Fig.  <a class="reference internal" href="#fig-idea-puerta-phiadd-a-mod-n"><span class="std std-numref">18.4</span></a>).</p></li>
</ul>
</li>
</ul>
</section>
<section id="circuito-final-con-2n-3-algoritmo-de-estimacion-iterativa-de-fase-ipe">
<span id="sec-2n-3-circuito-final-simplificado"></span><h2><span class="section-number">18.2.8. </span>Circuito final con <span class="math notranslate nohighlight">\(2n+3\)</span>. Algoritmo de estimación iterativa de fase (IPE)<a class="headerlink" href="#circuito-final-con-2n-3-algoritmo-de-estimacion-iterativa-de-fase-ipe" title="Permalink to this heading">#</a></h2>
<p>Nos faltaría implementar la simplificación del registro de conteo, donde se pasa de <span class="math notranslate nohighlight">\(2n\)</span> qúbits en el mismo a 1 (ver Fig.  <a class="reference internal" href="#fig-idea-circ-final-simpli"><span class="std std-numref">18.11</span></a>). Esta simplificación consiste en usar una versión mejorada del Algoritmo de Estimación de Fases Cuántico (QPE) denominado <b>Algoritmo de Estimación Iterativa de Fase</b> o Iterative Phase Estimation (IPE) Algorithm. Vamos a explicar como pasar del QPE al IPE en nuestro circuito. Para ello, vamos a ejemplificar el desarrollo con el circuito de 4 qúbits en el registro de conteo de la Fig.  <a class="reference internal" href="#fig-ipe-1"><span class="std std-numref">18.8</span></a>. Las puertas de colores del final no son más que la transformada de Fourier inversa. Vemos que al ser la inversa lo que hay que hacer es invertir el orden de las puertas del QFT normal (ver Fig.  <a class="reference internal" href="Section_003_implementacion_aproximada_de_la_qft_myst.html#fig-2n-3-qft-exacta"><span class="std std-numref">18.12</span></a> y Fig.  <a class="reference internal" href="../Chapter_015_02/Section_003_circuito_que_implementa_la_qft_myst.html#fig-qft-circuit"><span class="std std-numref">15.2</span></a>).</p>
<figure class="align-center" id="fig-ipe-1">
<a class="reference internal image-reference" href="../../../_images/Fig_IPE_1.png"><img alt="../../../_images/Fig_IPE_1.png" src="../../../_images/Fig_IPE_1.png" style="width: 1000px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.8 </span><span class="caption-text">Ejemplo del algoritmo de Shor con 4 qúbits (en el convenio estándar). Las puertas de colores del final no son más que la transformada de Fourier inversa.</span><a class="headerlink" href="#fig-ipe-1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-center" id="fig-ipe-3">
<a class="reference internal image-reference" href="../../../_images/Fig_IPE_3.png"><img alt="../../../_images/Fig_IPE_3.png" src="../../../_images/Fig_IPE_3.png" style="width: 1000px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.9 </span><span class="caption-text">Ejemplo del algoritmo de Shor con 4 qúbits usando IPE (en el convenio estándar). Las puertas de colores no son más que la transformada de Fourier inversa.</span><a class="headerlink" href="#fig-ipe-3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Si nos fijamos, vemos que una vez que un qúbit controla su respectiva puerta <span class="math notranslate nohighlight">\(U_{a^{2^k}}\)</span> sobre este ya no aplican (ni controla) más puertas hasta llegar a las de la <span class="math notranslate nohighlight">\(QFT^{-1}\)</span>.  Podemos pues llevar a cabo sin ningún problema la reordenación de las puertas de color de la Fig.  <a class="reference internal" href="#fig-ipe-3"><span class="std std-numref">18.9</span></a>. Vemos sin embargo que hay otros dos cambios significativos:</p>
<ul class="simple">
<li><p>En vez de poner los 4 bit clásicos (en los que se almacenan las medidas) en una linea a parte, se han puesto a continuación del medidor. Esto es simplemente para no añadir 4 lineas más al circuito.</p></li>
<li><p>El gran cambio que introducimos en este circuito es el hecho de controlar puertas con bits clásicos.</p></li>
</ul>
<p>En el circuito de la Fig.  <a class="reference internal" href="#fig-ipe-3"><span class="std std-numref">18.9</span></a> ya se han colocado las puertas para que se vea bien que estas se pueden aplicar de forma secuencial qúbit por qúbit. Es decir, primero se aplican las puertas sobre el qúbit de abajo del todo (en el registro de conteo) y se mide. Después se va a por siguiente qúbit y se mide, y así sucesivamente. La gracia es que, una vez que se mide un qúbit, el valor de esta medida se va usar para controlar puertas que se aplican en los siguientes qúbit. Lo importante es que, como ya comentamos, estas medidas se almacenan en bits clásicos, con lo cual, una vez que se ha medido un qúbit, este deja de ser necesario. De la misma forma, al ir aplicando las puertas de forma secuencial qúbit por qúbit, mientras se aplican las puertas a los qúbits anteriores, lo qúbits siguientes también son “inutiles”.</p>
<p>Siguiendo estos argumentos, podemos ver que en realidad, solo nos hace falta un qúbit en el registro de conteo. Esto es lo que podemos ver en la Fig.  <a class="reference internal" href="#fig-ipe-4"><span class="std std-numref">18.10</span></a>. Como vemos, tenemos solo un qúbit en el registro de conteo.</p>
<ul class="simple">
<li><p>Lo que se hace es primero aplicar sobre este qúbit las puertas que aplicaríamos sobre el último qúbit del registro de conteo y después medir. Almacenamos esta medida en un bit clásico. Una vez medido, podemos usar el valor del bit clásico para controlar una puerta <span class="math notranslate nohighlight">\(X\)</span>. De esta forma, lo que hacemos es devolver el qúbit al estado inicial (el estado <span class="math notranslate nohighlight">\(| 0 \rangle\)</span>).</p></li>
<li><p>Una ver que volvemos a tener el qúbit en su estado de partida y la media del mismo a buen recaudo, podemos pasar a aplicar sobre este qúbit las puertas que aplicariamos sobre el siguiente qúbit del registro de conteo (una de ellas controlada por el bit clásico anterior) y medirlo, almacenando su valor en un segundo bit clásico. Nuevamente, usamos una puerta <span class="math notranslate nohighlight">\(X\)</span> controlada por este segundo bit clásico para devolver el qúbit al estado inicial.</p></li>
</ul>
<p>Y así, sucesivamente. Para más detalles, pueden verse las referencias <span id="id7">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id29" title="Michele Mosca and Artur Ekert. The hidden subgroup problem and eigenvalue estimation on a quantum computer. 1999. URL: https://arxiv.org/abs/quant-ph/9903071, doi:10.48550/ARXIV.QUANT-PH/9903071.">42</a>]</span>, <span id="id8">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id30" title="Christof Zalka. Fast versions of shor's quantum factoring algorithm. 1998. URL: https://arxiv.org/abs/quant-ph/9806084, doi:10.48550/ARXIV.QUANT-PH/9806084.">62</a>]</span> y <span id="id9">[<a class="reference internal" href="../../Chapter_Bibliografia_myst.html#id31" title="S. Parker and M. B. Plenio. Efficient factorization with a single pure qubit and $\mathrm log\mathit N$ mixed qubits. Phys. Rev. Lett., 85:3049–3052, Oct 2000. URL: https://link.aps.org/doi/10.1103/PhysRevLett.85.3049, doi:10.1103/PhysRevLett.85.3049.">45</a>]</span></p>
<p>Extrapolando al caso de <span class="math notranslate nohighlight">\(2n\)</span> qúbits en el registro de conteo (el caso del algoritmo de Shor), nuestro circuito final sería el de la Fig.  <a class="reference internal" href="#fig-idea-circ-final-simpli"><span class="std std-numref">18.11</span></a>, donde las <span class="math notranslate nohighlight">\(m_k\)</span> se refiere a medidas, las <span class="math notranslate nohighlight">\(X^{m_k}\)</span> se refiere a aplicar la puerta <span class="math notranslate nohighlight">\(X\)</span> controlada por las medida anterior y las <span class="math notranslate nohighlight">\(R_k\)</span> se refiere a aplicar las puertas <span class="math notranslate nohighlight">\(P_\phi\)</span> de la QFT controladas por las medias anteriores.</p>
<figure class="align-center" id="fig-ipe-4">
<a class="reference internal image-reference" href="../../../_images/Fig_IPE_4.png"><img alt="../../../_images/Fig_IPE_4.png" src="../../../_images/Fig_IPE_4.png" style="width: 800px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.10 </span><span class="caption-text">Circuito final con <span class="math notranslate nohighlight">\(2n+3\)</span> qúbits (ejemplo con 4 qúbits).</span><a class="headerlink" href="#fig-ipe-4" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-center" id="fig-idea-circ-final-simpli">
<a class="reference internal image-reference" href="../../../_images/Fig-Truco-qubit-control.png"><img alt="../../../_images/Fig-Truco-qubit-control.png" src="../../../_images/Fig-Truco-qubit-control.png" style="width: 700px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 18.11 </span><span class="caption-text">Circuito final con <span class="math notranslate nohighlight">\(2n+3\)</span> qúbits (en el convenio estándar).</span><a class="headerlink" href="#fig-idea-circ-final-simpli" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<figure class="align-center">
<a class="reference internal image-reference" href="https://quantumspain-project.es/wp-content/uploads/2022/11/Logo_QS_EspanaDigital.png"><img alt="https://quantumspain-project.es/wp-content/uploads/2022/11/Logo_QS_EspanaDigital.png" src="https://quantumspain-project.es/wp-content/uploads/2022/11/Logo_QS_EspanaDigital.png" style="width: 2000px;" /></a>
</figure>
<center>
<img align="left" src="https://quantumspain-project.es/wp-content/uploads/2024/02/Banner-QS_GOB_v2.png" width="1000px" />
</center></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./docs/Part_04/Chapter_018_02"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="Section_001_la_idea__myst.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">18.1. </span>La idea</p>
      </div>
    </a>
    <a class="right-next"
       href="Section_003_implementacion_aproximada_de_la_qft_myst.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">18.3. </span>Implementación aproximada de la QFT</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#algoritmo-cuantico-de-suma">18.2.1. Algoritmo cuántico de suma</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#valor-clasico-registro-cuantico-puerta-phi-add-a">18.2.2. Valor clásico + registro cuántico (puerta <span class="math notranslate nohighlight">\(\phi ADD(a)\)</span>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#suma-modulada-puerta-phi-add-a-mod-n">18.2.3. Suma modulada (puerta <span class="math notranslate nohighlight">\(\phi ADD(a)MOD(N)\)</span>)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caso-con-c-1-c-2-1">18.2.3.1. Caso con <span class="math notranslate nohighlight">\(c_1 = c_2 = 1\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#caso-con-c-1-0-y-o-c-2-0">18.2.3.2. Caso con <span class="math notranslate nohighlight">\(c_1 = 0\)</span> y/o <span class="math notranslate nohighlight">\(c_2 = 0\)</span>.</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiplicacion-modulada-puerta-cmult-a-mod-n">18.2.4. Multiplicación modulada (puerta <span class="math notranslate nohighlight">\(CMULT(a)MOD(N)\)</span>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#puerta-controlada-c-text-u-a">18.2.5. Puerta controlada <span class="math notranslate nohighlight">\(C\text{-}U_a\)</span></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exponencial-modulada-puerta-c-text-u-a-s">18.2.6. Exponencial modulada (puerta <span class="math notranslate nohighlight">\(C\text{-}U_{a^{s}}\)</span>)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#circuito-final-con-4n-2-qubits-sin-la-simplificacion-del-registro-de-conteo">18.2.7. Circuito final con <span class="math notranslate nohighlight">\(4n+2\)</span> qúbits (sin la simplificación del registro de conteo)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#circuito-final-con-2n-3-algoritmo-de-estimacion-iterativa-de-fase-ipe">18.2.8. Circuito final con <span class="math notranslate nohighlight">\(2n+3\)</span>. Algoritmo de estimación iterativa de fase (IPE)</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By David Castaño Bandín
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>